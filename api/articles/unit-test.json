{"title":"","slug":"unit-test","date":"2017-11-06T11:37:21.388Z","updated":"2017-11-06T11:37:24.653Z","comments":true,"excerpt":"","content":"<p>原文发于我的博客：<a href=\"https://github.com/hwen/blogSome/issues/1\">https://github.com/hwen/blogSome/issues/1</a></p>\n<h2 id=\"要不要写单测？\"><a href=\"#要不要写单测？\" class=\"headerlink\" title=\"要不要写单测？\"></a>要不要写单测？</h2><p>关于这个 cnode 上就有个很有意思的讨论</p>\n<p><a href=\"https://cnodejs.org/topic/596d770c8f05de0819fdb2b5\" target=\"_blank\" rel=\"external\">做个调查，你的 Node 应用有写单测吗？</a></p>\n<p>看完这个应该会有结论？如果没有，就回帖跟别人探讨下~</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>测试有分为</p>\n<ul>\n<li>单元测试（单测）</li>\n<li>集成测试</li>\n<li>系统测试</li>\n</ul>\n<p>主要区别是单测倾向于测试模块内部运行逻辑及功能，集成测试倾向于模块间互相组合跟调用的测试。<br>系统测试（当然你要说，还有自动化测试）是对整个系统的测试，主要由测试人员而非开发人员负责。</p>\n<p>本文只讨论单测的范畴，对集成测试有兴趣的话，可以看下 Vue 的集成测试代码。</p>\n<h2 id=\"前端单测现状\"><a href=\"#前端单测现状\" class=\"headerlink\" title=\"前端单测现状\"></a>前端单测现状</h2><p>测试本质上就是假定一个输入，然后判断得到预期的输出。而前端与后端相比，夹杂着浏览器 DOM 操作，异步请求，<br>浏览器兼容性等方面的。要我来说，比后端写单测要麻烦多了。。。</p>\n<p>不过现在前端的单测已经发展得比较完善了，已经有一套比较完整的工具链，来完成各种需求。</p>\n<h2 id=\"单测工具链\"><a href=\"#单测工具链\" class=\"headerlink\" title=\"单测工具链\"></a>单测工具链</h2><h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><p>目前比较流行的测试框架有：</p>\n<ul>\n<li><a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"external\">jasmine</a>： 自带断言（assert），mock 功能</li>\n<li><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">mocha</a>：框架不带断言和mock功能，需要结合其他工具。mocha 是 tj 大神写的（tj 就是那个写了express、koa、n、co、ejs的人。。。）</li>\n</ul>\n<p>用得比较多的就上面两个，还有一些用得比较少的，比如 <a href=\"https://qunitjs.com/\" target=\"_blank\" rel=\"external\">Qunit</a>、<a href=\"https://theintern.io/\" target=\"_blank\" rel=\"external\">intern</a> </p>\n<p>框架的实现原理其实就是检测内部运行的代码是否有抛出异常。而断言库如果没有得到预期的输入时，就会抛出异常，给框架检测到。</p>\n<p>PS.想要学 mocha 和单测写法，最好的资源就是 express 框架的测试代码（狼叔推荐，亲测很不错）</p>\n<h3 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h3><ul>\n<li><a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"external\">chai</a>：目前比较流行的断言库，支持 TDD（assert），BDD（expect、should）两种风格</li>\n<li><a href=\"https://shouldjs.github.io/\" target=\"_blank\" rel=\"external\">shouldjs</a>：也是 tj 写的，说实话我比较喜欢这个，但是有坑。。。后面会说到。。。</li>\n<li>expectjs：基本是 shouldjs 的缩水版</li>\n<li><a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/assert.html\" target=\"_blank\" rel=\"external\">assert</a>：node 的核心模块，node 环境可以直接使用</li>\n</ul>\n<h3 id=\"mock-库\"><a href=\"#mock-库\" class=\"headerlink\" title=\"mock 库\"></a>mock 库</h3><ul>\n<li><a href=\"http://sinonjs.org/\" target=\"_blank\" rel=\"external\">sinon.js</a>：只用过这个，其他不大清楚。不过这个是目前最多人用的，基本够了。支持 <code>spies</code>, <code>stub</code>, <code>fake XMLHttpRequest</code>, <code>Fake server</code>, <code>Fake time</code>，很强大</li>\n</ul>\n<h3 id=\"测试集成工具\"><a href=\"#测试集成工具\" class=\"headerlink\" title=\"测试集成工具\"></a>测试集成工具</h3><ul>\n<li><a href=\"https://karma-runner.github.io\" target=\"_blank\" rel=\"external\">karma</a>：Google Angular 团队写的，功能很强大，有很多插件</li>\n<li>buster.js: 这个支持 node 环境，但目前还在 beta 版（2017/11/4，版本0.7）。<a href=\"http://docs.busterjs.org/en/latest/#project-resources\" target=\"_blank\" rel=\"external\">官网</a></li>\n</ul>\n<h2 id=\"半小时上手单测\"><a href=\"#半小时上手单测\" class=\"headerlink\" title=\"半小时上手单测\"></a>半小时上手单测</h2><p>(并不是学会，就是这么耿直 <em>(:з)∠)</em>，手是谁？？？)</p>\n<p>使用的是：karma + mocha + chai + sinon（如果之前没了解过这几个，可以边写边看文档，这样学会快很多）</p>\n<p>完整的例子可以在这里找到：<a href=\"https://github.com/hwen/learnSome/blob/master/unit-test/test/index.test.js\">GitHub 项目</a><br>建议把项目 clone 下来自己跑一遍，然后可以<strong>自己加一些特效</strong>（啊，不对，是代码才对。。。</p>\n<h3 id=\"测试-DOM\"><a href=\"#测试-DOM\" class=\"headerlink\" title=\"测试 DOM\"></a>测试 DOM</h3><p>详细代码，及配置见 <a href=\"https://github.com/hwen/learnSome/blob/master/unit-test/test/index.test.js\">源码</a></p>\n\n    <pre><code class=\"lang-js\">it(<span class=\"hljs-string\">'test dom'</span>, () =&gt; {\n  <span class=\"hljs-keyword\">const</span> div = document.getElementById(<span class=\"hljs-string\">'test'</span>)\n\n  <span class=\"hljs-keyword\">const</span> content = div.innerHTML\n  content.should.be.equal(<span class=\"hljs-string\">'here'</span>)\n\n  setDivContent()\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">after</span> = div.innerHTML\n  <span class=\"hljs-keyword\">after</span>.should.be.<span class=\"hljs-title\">equal</span>('hallo world')\n})\n</code></pre>\n<h3 id=\"测试异步请求\"><a href=\"#测试异步请求\" class=\"headerlink\" title=\"测试异步请求\"></a>测试异步请求</h3>\n    <pre><code class=\"lang-js\">it('test async', done =&gt; {\n  getTopics()\n    .then(<span class=\"hljs-name\">res</span> =&gt; {\n      res.success.should.be.equal(<span class=\"hljs-name\">true</span>)\n      done()\n    })\n    .catch(<span class=\"hljs-name\">err</span> =&gt; {\n      info(<span class=\"hljs-name\">err</span>)\n      done(<span class=\"hljs-name\">err</span>)\n    })\n\n})\n</code></pre>\n<h2 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h2><h3 id=\"调试技巧之一：善用-only\"><a href=\"#调试技巧之一：善用-only\" class=\"headerlink\" title=\"调试技巧之一：善用 only\"></a>调试技巧之一：善用 only</h3><p>当你的单元测试越写越多时，想测试新写的单测是否正确时，可以用 mocha 的 only<br>这样做的好处有二：第一屏蔽其他测试可以使测试速度变得更快，第二屏蔽其他测试，可以在你新写的测试错误时<br>确定这个错误不是被其他测试所影响导致的。</p>\n<p>用法</p>\n\n    <pre><code class=\"lang-js\">describe.only(<span class=\"hljs-string\">'something'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-comment\">// 只会跑包在里面的测试</span>\n})\n</code></pre>\n<p>或者</p>\n\n    <pre><code class=\"lang-js\">it.only(<span class=\"hljs-string\">'do do'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-regexp\">//</span> 只会跑这一个测试\n})\n</code></pre>\n<h3 id=\"调试技巧之二：善用-debug\"><a href=\"#调试技巧之二：善用-debug\" class=\"headerlink\" title=\"调试技巧之二：善用 debug\"></a>调试技巧之二：善用 debug</h3><p>要开启 debug 的话，先在 <code>karma.conf.js</code> 把 <code>singleRun</code> 改成 <code>false</code><br>然后，看图（懒得打字了 <em>(:з)∠)</em></p>\n<p><img src=\"https://user-images.githubusercontent.com/6712767/32413398-aa203450-c24b-11e7-966f-1e857ba69b95.gif\" alt=\"debug\"></p>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>生成覆盖率报告也是相当简单，不过有个要注意的地方就是<br>现在前端代码很多都是经过 <code>webpack</code>，<code>babel</code> 编译的，生成的代码会多了很多二外的代码</p>\n<p>要解决这个问题使用<code>babel-plugin-istanbul</code>来替代<code>karma-coverage</code>就可以了</p>\n\n    <pre><code class=\"lang-js\">    preprocessors: {\n      <span class=\"hljs-string\">'src/**/*.js'</span>: [<span class=\"hljs-string\">'webpack'</span>, <span class=\"hljs-string\">'coverage'</span>],\n      <span class=\"hljs-string\">'test/*.test.js'</span>: [<span class=\"hljs-string\">'webpack'</span>]\n    }\n</code></pre>\n<p>将 karma-coverage 去掉,变成</p>\n\n    <pre><code class=\"lang-js\">    preprocessors: {\n      <span class=\"hljs-string\">'src/**/*.js'</span>: [<span class=\"hljs-string\">'webpack'</span>],\n      <span class=\"hljs-string\">'test/*.test.js'</span>: [<span class=\"hljs-string\">'webpack'</span>]\n    }\n</code></pre>\n<p>然后在 webpack 配置添加 istanbul 插件</p>\n\n    <pre><code class=\"lang-js\">  <span class=\"hljs-selector-tag\">use</span>: {\n    <span class=\"hljs-attribute\">loader</span>: <span class=\"hljs-string\">'babel-loader'</span>,\n    options: {\n      plugins: [<span class=\"hljs-string\">'istanbul'</span>]\n    }\n  }\n</code></pre>\n<p>最后可以生成覆盖率报告</p>\n<p><img src=\"https://user-images.githubusercontent.com/6712767/32413426-2506f474-c24c-11e7-8637-7ef9e585e639.png\" alt=\"cover1\"><br><img src=\"https://user-images.githubusercontent.com/6712767/32413431-2889232e-c24c-11e7-9cb2-1d1b158440fa.png\" alt=\"cov2\"></p>\n<p>另外有很多工具可以对生成的覆盖率报告进行进一步的分析，比如最常见的<br>你会在 Github 上经常见到的图标</p>\n<p><img src=\"https://user-images.githubusercontent.com/6712767/32413432-2d70f218-c24c-11e7-83d8-6a7629173f64.png\" alt=\"cov-icon\"></p>\n<p>这个就是利用报告里的<code>lcovonly</code>分析生成的</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-attribute\">coverageReporter</span>: {\n  <span class=\"hljs-attribute\">dir</span>: <span class=\"hljs-string\">'test/coverage/'</span>,\n  <span class=\"hljs-attribute\">reporters</span>: [\n    { <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'html'</span>, <span class=\"hljs-attribute\">subdir</span>: <span class=\"hljs-string\">'report-html'</span> },\n    { <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'lcovonly'</span>, <span class=\"hljs-attribute\">subdir</span>: <span class=\"hljs-string\">'.'</span>, <span class=\"hljs-attribute\">file</span>: <span class=\"hljs-string\">'report-lcovonly.txt'</span> },  <span class=\"hljs-comment\">// 这里，你可以重命名 file</span>\n    { <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'text-summary'</span>, <span class=\"hljs-attribute\">subdir</span>: <span class=\"hljs-string\">'.'</span>, <span class=\"hljs-attribute\">file</span>: <span class=\"hljs-string\">'text-summary.txt'</span> }\n  ]\n}\n</code></pre>\n<h2 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h2><ul>\n<li>测试时如果有涉及浏览器事件（addEventListener），记得测试完移除掉，不然会对其他的测试造成影响（afterEach -&gt; removeEventListener）</li>\n<li>mocha 里使用箭头函数需要注意，因为箭头函数的 this 指向是静态的，所以 this 并不指向 mocha（没有 mocha 上下文）</li>\n<li>上面有说到，如果测试的是经过编译的代码，需要进行一些配置，目前的办法是用<code>babel-plugin-istanbul</code>代替<code>karma-cover</code>来检测覆盖率</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>前面有说到，为什么不用 <code>should.js</code>？？<br>因为如果你用 ES6 的语法写单测（webpack 编译），用 import should-sinon 会报错。。<br>（是不是因为 tj 大神写完东西不喜欢维护的习惯导致should.js支持性不好？？？）</p>\n","categories":[],"tags":[]}